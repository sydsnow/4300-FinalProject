{"version":3,"file":"eliminateUnreferencedIdentifiers.js","sources":["../../src/eliminateUnreferencedIdentifiers.ts"],"sourcesContent":["// Copied from https://github.com/pcattori/vite-env-only/blob/main/src/dce.ts\n// Adapted with some minor changes for the purpose of this project\n\nimport * as t from '@babel/types'\nimport type { types as BabelTypes } from '@babel/core'\nimport type { NodePath } from '@babel/traverse'\n\ntype IdentifierPath = NodePath<BabelTypes.Identifier>\n\n// export function findReferencedIdentifiers(\n//   programPath: NodePath<BabelTypes.Program>,\n// ): Set<IdentifierPath> {\n//   const refs = new Set<IdentifierPath>()\n\n//   function markFunction(\n//     path: NodePath<\n//       | BabelTypes.FunctionDeclaration\n//       | BabelTypes.FunctionExpression\n//       | BabelTypes.ArrowFunctionExpression\n//     >,\n//   ) {\n//     const ident = getIdentifier(path)\n//     if (ident?.node && isIdentifierReferenced(ident)) {\n//       refs.add(ident)\n//     }\n//   }\n\n//   function markImport(\n//     path: NodePath<\n//       | BabelTypes.ImportSpecifier\n//       | BabelTypes.ImportDefaultSpecifier\n//       | BabelTypes.ImportNamespaceSpecifier\n//     >,\n//   ) {\n//     const local = path.get('local')\n//     if (isIdentifierReferenced(local)) {\n//       refs.add(local)\n//     }\n//   }\n\n//   programPath.traverse({\n//     VariableDeclarator(path) {\n//       if (path.node.id.type === 'Identifier') {\n//         const local = path.get('id') as NodePath<BabelTypes.Identifier>\n//         if (isIdentifierReferenced(local)) {\n//           refs.add(local)\n//         }\n//       } else if (path.node.id.type === 'ObjectPattern') {\n//         const pattern = path.get('id') as NodePath<BabelTypes.ObjectPattern>\n\n//         const properties = pattern.get('properties')\n//         properties.forEach((p) => {\n//           const local = p.get(\n//             p.node.type === 'ObjectProperty'\n//               ? 'value'\n//               : p.node.type === 'RestElement'\n//                 ? 'argument'\n//                 : (function () {\n//                     throw new Error('invariant')\n//                   })(),\n//           ) as NodePath<BabelTypes.Identifier>\n//           if (isIdentifierReferenced(local)) {\n//             refs.add(local)\n//           }\n//         })\n//       } else if (path.node.id.type === 'ArrayPattern') {\n//         const pattern = path.get('id') as NodePath<BabelTypes.ArrayPattern>\n\n//         const elements = pattern.get('elements')\n//         elements.forEach((e) => {\n//           let local: NodePath<BabelTypes.Identifier>\n//           if (e.node?.type === 'Identifier') {\n//             local = e as NodePath<BabelTypes.Identifier>\n//           } else if (e.node?.type === 'RestElement') {\n//             local = e.get('argument') as NodePath<BabelTypes.Identifier>\n//           } else {\n//             return\n//           }\n\n//           if (isIdentifierReferenced(local)) {\n//             refs.add(local)\n//           }\n//         })\n//       }\n//     },\n\n//     FunctionDeclaration: markFunction,\n//     FunctionExpression: markFunction,\n//     ArrowFunctionExpression: markFunction,\n//     ImportSpecifier: markImport,\n//     ImportDefaultSpecifier: markImport,\n//     ImportNamespaceSpecifier: markImport,\n//   })\n//   return refs\n// }\n\n/**\n * @param refs - If provided, only these identifiers will be considered for removal.\n */\nexport const eliminateUnreferencedIdentifiers = (\n  programPath: NodePath<BabelTypes.Program>,\n  refs?: Set<IdentifierPath>,\n) => {\n  let referencesRemovedInThisPass: number\n\n  const shouldBeRemoved = (ident: IdentifierPath) => {\n    if (isIdentifierReferenced(ident)) return false\n    if (!refs) return true\n    return refs.has(ident)\n  }\n\n  const sweepFunction = (\n    path: NodePath<\n      | BabelTypes.FunctionDeclaration\n      | BabelTypes.FunctionExpression\n      | BabelTypes.ArrowFunctionExpression\n    >,\n  ) => {\n    const identifier = getIdentifier(path)\n    if (identifier?.node && shouldBeRemoved(identifier)) {\n      ++referencesRemovedInThisPass\n\n      if (\n        t.isAssignmentExpression(path.parentPath.node) ||\n        t.isVariableDeclarator(path.parentPath.node)\n      ) {\n        path.parentPath.remove()\n      } else {\n        path.remove()\n      }\n    }\n  }\n\n  const sweepImport = (\n    path: NodePath<\n      | BabelTypes.ImportSpecifier\n      | BabelTypes.ImportDefaultSpecifier\n      | BabelTypes.ImportNamespaceSpecifier\n    >,\n  ) => {\n    const local = path.get('local')\n    if (shouldBeRemoved(local)) {\n      ++referencesRemovedInThisPass\n      path.remove()\n      if (\n        (path.parent as BabelTypes.ImportDeclaration).specifiers.length === 0\n      ) {\n        path.parentPath.remove()\n      }\n    }\n  }\n\n  // Traverse again to remove unused references. This happens at least once,\n  // then repeats until no more references are removed.\n  do {\n    referencesRemovedInThisPass = 0\n\n    programPath.scope.crawl()\n\n    programPath.traverse({\n      VariableDeclarator(path) {\n        if (path.node.id.type === 'Identifier') {\n          const local = path.get('id') as NodePath<BabelTypes.Identifier>\n          if (shouldBeRemoved(local)) {\n            ++referencesRemovedInThisPass\n            path.remove()\n          }\n        } else if (path.node.id.type === 'ObjectPattern') {\n          const pattern = path.get('id') as NodePath<BabelTypes.ObjectPattern>\n\n          const beforeCount = referencesRemovedInThisPass\n          const properties = pattern.get('properties')\n          properties.forEach((property) => {\n            const local = property.get(\n              property.node.type === 'ObjectProperty'\n                ? 'value'\n                : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  property.node.type === 'RestElement'\n                  ? 'argument'\n                  : (function () {\n                      throw new Error('invariant')\n                    })(),\n            ) as NodePath<BabelTypes.Identifier>\n\n            if (shouldBeRemoved(local)) {\n              ++referencesRemovedInThisPass\n              property.remove()\n            }\n          })\n\n          if (\n            beforeCount !== referencesRemovedInThisPass &&\n            pattern.get('properties').length < 1\n          ) {\n            path.remove()\n          }\n        } else if (path.node.id.type === 'ArrayPattern') {\n          const pattern = path.get('id') as NodePath<BabelTypes.ArrayPattern>\n\n          let hasRemoved = false as boolean\n\n          pattern.get('elements').forEach((element, index) => {\n            // if (!element) return // Skip holes in the pattern\n\n            let identifierPath: NodePath<BabelTypes.Identifier>\n\n            if (t.isIdentifier(element.node)) {\n              identifierPath = element as NodePath<BabelTypes.Identifier>\n            } else if (t.isRestElement(element.node)) {\n              identifierPath = element.get(\n                'argument',\n              ) as NodePath<BabelTypes.Identifier>\n            } else {\n              // For now, ignore other types like AssignmentPattern\n              return\n            }\n\n            if (shouldBeRemoved(identifierPath)) {\n              hasRemoved = true\n              pattern.node.elements[index] = null // Remove the element by setting it to null\n            }\n          })\n\n          // If any elements were removed and no elements are left, remove the entire declaration\n          if (\n            hasRemoved &&\n            pattern.node.elements.every((element) => element === null)\n          ) {\n            path.remove()\n            ++referencesRemovedInThisPass\n          }\n        }\n      },\n      FunctionDeclaration: sweepFunction,\n      FunctionExpression: sweepFunction,\n      ArrowFunctionExpression: sweepFunction,\n      ImportSpecifier: sweepImport,\n      ImportDefaultSpecifier: sweepImport,\n      ImportNamespaceSpecifier: sweepImport,\n    })\n  } while (referencesRemovedInThisPass)\n}\n\nfunction getIdentifier(\n  path: NodePath<\n    | BabelTypes.FunctionDeclaration\n    | BabelTypes.FunctionExpression\n    | BabelTypes.ArrowFunctionExpression\n  >,\n): NodePath<BabelTypes.Identifier> | null {\n  const parentPath = path.parentPath\n  if (parentPath.type === 'VariableDeclarator') {\n    const variablePath = parentPath as NodePath<BabelTypes.VariableDeclarator>\n    const name = variablePath.get('id')\n    return name.node.type === 'Identifier'\n      ? (name as NodePath<BabelTypes.Identifier>)\n      : null\n  }\n\n  if (parentPath.type === 'AssignmentExpression') {\n    const variablePath = parentPath as NodePath<BabelTypes.AssignmentExpression>\n    const name = variablePath.get('left')\n    return name.node.type === 'Identifier'\n      ? (name as NodePath<BabelTypes.Identifier>)\n      : null\n  }\n\n  if (path.node.type === 'ArrowFunctionExpression') {\n    return null\n  }\n\n  if (path.node.type === 'FunctionExpression') {\n    return null\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return path.node.id && path.node.id.type === 'Identifier'\n    ? (path.get('id') as NodePath<BabelTypes.Identifier>)\n    : null\n}\n\nfunction isIdentifierReferenced(\n  ident: NodePath<BabelTypes.Identifier>,\n): boolean {\n  const binding = ident.scope.getBinding(ident.node.name)\n  if (binding?.referenced) {\n    // Functions can reference themselves, so we need to check if there's a\n    // binding outside the function scope or not.\n    if (binding.path.type === 'FunctionDeclaration') {\n      return !binding.constantViolations\n        .concat(binding.referencePaths)\n        // Check that every reference is contained within the function:\n        .every((ref) => ref.findParent((parent) => parent === binding.path))\n    }\n\n    return true\n  }\n  return false\n}\n"],"names":[],"mappings":"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"}