import * as t from "@babel/types";
const eliminateUnreferencedIdentifiers = (programPath, refs) => {
  let referencesRemovedInThisPass;
  const shouldBeRemoved = (ident) => {
    if (isIdentifierReferenced(ident))
      return false;
    if (!refs)
      return true;
    return refs.has(ident);
  };
  const sweepFunction = (path) => {
    const identifier = getIdentifier(path);
    if ((identifier == null ? void 0 : identifier.node) && shouldBeRemoved(identifier)) {
      ++referencesRemovedInThisPass;
      if (t.isAssignmentExpression(path.parentPath.node) || t.isVariableDeclarator(path.parentPath.node)) {
        path.parentPath.remove();
      } else {
        path.remove();
      }
    }
  };
  const sweepImport = (path) => {
    const local = path.get("local");
    if (shouldBeRemoved(local)) {
      ++referencesRemovedInThisPass;
      path.remove();
      if (path.parent.specifiers.length === 0) {
        path.parentPath.remove();
      }
    }
  };
  do {
    referencesRemovedInThisPass = 0;
    programPath.scope.crawl();
    programPath.traverse({
      VariableDeclarator(path) {
        if (path.node.id.type === "Identifier") {
          const local = path.get("id");
          if (shouldBeRemoved(local)) {
            ++referencesRemovedInThisPass;
            path.remove();
          }
        } else if (path.node.id.type === "ObjectPattern") {
          const pattern = path.get("id");
          const beforeCount = referencesRemovedInThisPass;
          const properties = pattern.get("properties");
          properties.forEach((property) => {
            const local = property.get(
              property.node.type === "ObjectProperty" ? "value" : (
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                property.node.type === "RestElement" ? "argument" : function() {
                  throw new Error("invariant");
                }()
              )
            );
            if (shouldBeRemoved(local)) {
              ++referencesRemovedInThisPass;
              property.remove();
            }
          });
          if (beforeCount !== referencesRemovedInThisPass && pattern.get("properties").length < 1) {
            path.remove();
          }
        } else if (path.node.id.type === "ArrayPattern") {
          const pattern = path.get("id");
          let hasRemoved = false;
          pattern.get("elements").forEach((element, index) => {
            let identifierPath;
            if (t.isIdentifier(element.node)) {
              identifierPath = element;
            } else if (t.isRestElement(element.node)) {
              identifierPath = element.get(
                "argument"
              );
            } else {
              return;
            }
            if (shouldBeRemoved(identifierPath)) {
              hasRemoved = true;
              pattern.node.elements[index] = null;
            }
          });
          if (hasRemoved && pattern.node.elements.every((element) => element === null)) {
            path.remove();
            ++referencesRemovedInThisPass;
          }
        }
      },
      FunctionDeclaration: sweepFunction,
      FunctionExpression: sweepFunction,
      ArrowFunctionExpression: sweepFunction,
      ImportSpecifier: sweepImport,
      ImportDefaultSpecifier: sweepImport,
      ImportNamespaceSpecifier: sweepImport
    });
  } while (referencesRemovedInThisPass);
};
function getIdentifier(path) {
  const parentPath = path.parentPath;
  if (parentPath.type === "VariableDeclarator") {
    const variablePath = parentPath;
    const name = variablePath.get("id");
    return name.node.type === "Identifier" ? name : null;
  }
  if (parentPath.type === "AssignmentExpression") {
    const variablePath = parentPath;
    const name = variablePath.get("left");
    return name.node.type === "Identifier" ? name : null;
  }
  if (path.node.type === "ArrowFunctionExpression") {
    return null;
  }
  if (path.node.type === "FunctionExpression") {
    return null;
  }
  return path.node.id && path.node.id.type === "Identifier" ? path.get("id") : null;
}
function isIdentifierReferenced(ident) {
  const binding = ident.scope.getBinding(ident.node.name);
  if (binding == null ? void 0 : binding.referenced) {
    if (binding.path.type === "FunctionDeclaration") {
      return !binding.constantViolations.concat(binding.referencePaths).every((ref) => ref.findParent((parent) => parent === binding.path));
    }
    return true;
  }
  return false;
}
export {
  eliminateUnreferencedIdentifiers
};
//# sourceMappingURL=eliminateUnreferencedIdentifiers.js.map
