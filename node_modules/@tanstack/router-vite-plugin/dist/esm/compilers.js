import * as t from "@babel/types";
import * as template from "@babel/template";
import * as babel from "@babel/core";
import { splitPrefix } from "./constants.js";
import { eliminateUnreferencedIdentifiers } from "./eliminateUnreferencedIdentifiers.js";
function makeCompile(makeOpts) {
  return async (opts) => {
    const res = await babel.transform(opts.code, {
      plugins: [
        ["@babel/plugin-syntax-jsx", {}],
        [
          "@babel/plugin-syntax-typescript",
          {
            isTSX: true
          }
        ],
        ...opts.getBabelConfig().plugins
      ],
      root: makeOpts.root,
      filename: opts.filename,
      sourceMaps: true
    });
    if (res == null ? void 0 : res.code) {
      return {
        code: res.code,
        map: res.map
      };
    }
    return {
      code: opts.code,
      map: null
    };
  };
}
async function compileFile(opts) {
  return await opts.compile({
    code: opts.code,
    filename: opts.filename,
    getBabelConfig: () => ({
      plugins: [
        [
          {
            visitor: {
              Program: {
                enter(programPath, state) {
                  const splitUrl = `${splitPrefix}:${opts.filename}?${splitPrefix}`;
                  programPath.traverse(
                    {
                      CallExpression: (path) => {
                        if (path.node.callee.type === "Identifier") {
                          if (path.node.callee.name === "createRoute" || path.node.callee.name === "createFileRoute") {
                            if (path.parentPath.node.type === "CallExpression") {
                              const options = resolveIdentifier(
                                path,
                                path.parentPath.node.arguments[0]
                              );
                              let found = false;
                              if (t.isObjectExpression(options)) {
                                options.properties.forEach((prop) => {
                                  if (t.isObjectProperty(prop)) {
                                    if (t.isIdentifier(prop.key)) {
                                      if (prop.key.name === "component") {
                                        const value = prop.value;
                                        if (t.isIdentifier(value)) {
                                          removeIdentifierLiteral(path, value);
                                        }
                                        programPath.unshiftContainer("body", [
                                          template.smart(
                                            `import { lazyRouteComponent } from '@tanstack/react-router'`
                                          )(),
                                          template.smart(
                                            `const $$splitComponentImporter = () => import('${splitUrl}')`
                                          )()
                                        ]);
                                        prop.value = template.expression(
                                          `lazyRouteComponent($$splitComponentImporter, 'component')`
                                        )();
                                        programPath.pushContainer("body", [
                                          template.smart(
                                            `function DummyComponent() { return null }`
                                          )()
                                        ]);
                                        found = true;
                                      } else if (prop.key.name === "loader") {
                                        const value = prop.value;
                                        if (t.isIdentifier(value)) {
                                          removeIdentifierLiteral(path, value);
                                        }
                                        programPath.unshiftContainer("body", [
                                          template.smart(
                                            `import { lazyFn } from '@tanstack/react-router'`
                                          )(),
                                          template.smart(
                                            `const $$splitLoaderImporter = () => import('${splitUrl}')`
                                          )()
                                        ]);
                                        prop.value = template.expression(
                                          `lazyFn($$splitLoaderImporter, 'loader')`
                                        )();
                                        found = true;
                                      }
                                    }
                                  }
                                });
                              }
                              if (found) {
                                programPath.pushContainer("body", [
                                  template.smart(
                                    `function TSR_Dummy_Component() {}`
                                  )()
                                ]);
                              }
                            }
                          }
                        }
                      }
                    },
                    state
                  );
                  eliminateUnreferencedIdentifiers(programPath);
                }
              }
            }
          },
          {
            root: process.cwd(),
            minify: process.env.NODE_ENV === "production"
          }
        ]
      ].filter(Boolean)
    })
  });
}
function resolveIdentifier(path, node) {
  if (t.isIdentifier(node)) {
    const binding = path.scope.getBinding(node.name);
    if (binding) {
      const declarator = binding.path.node;
      if (t.isObjectExpression(declarator.init)) {
        return declarator.init;
      } else if (t.isFunctionDeclaration(declarator.init)) {
        return declarator.init;
      }
    }
    return void 0;
  }
  return node;
}
function removeIdentifierLiteral(path, node) {
  if (t.isIdentifier(node)) {
    const binding = path.scope.getBinding(node.name);
    if (binding) {
      binding.path.remove();
    }
  }
}
const splitNodeTypes = ["component", "loader"];
async function splitFile(opts) {
  return await opts.compile({
    code: opts.code,
    filename: opts.filename,
    getBabelConfig: () => ({
      plugins: [
        [
          {
            visitor: {
              Program: {
                enter(programPath, state) {
                  const splitNodesByType = {
                    component: void 0,
                    loader: void 0
                  };
                  programPath.traverse(
                    {
                      CallExpression: (path) => {
                        if (path.node.callee.type === "Identifier") {
                          if (path.node.callee.name === "createFileRoute") {
                            if (path.parentPath.node.type === "CallExpression") {
                              const options = resolveIdentifier(
                                path,
                                path.parentPath.node.arguments[0]
                              );
                              if (t.isObjectExpression(options)) {
                                options.properties.forEach((prop) => {
                                  if (t.isObjectProperty(prop)) {
                                    splitNodeTypes.forEach((type) => {
                                      if (t.isIdentifier(prop.key)) {
                                        if (prop.key.name === type) {
                                          splitNodesByType[type] = prop.value;
                                        }
                                      }
                                    });
                                  }
                                });
                                options.properties = [];
                              }
                            }
                          }
                        }
                      }
                    },
                    state
                  );
                  splitNodeTypes.forEach((splitType) => {
                    let splitNode = splitNodesByType[splitType];
                    if (!splitNode) {
                      return;
                    }
                    while (t.isIdentifier(splitNode)) {
                      const binding = programPath.scope.getBinding(
                        splitNode.name
                      );
                      splitNode = binding == null ? void 0 : binding.path.node;
                    }
                    if (splitNode) {
                      if (t.isFunctionDeclaration(splitNode)) {
                        programPath.pushContainer(
                          "body",
                          t.variableDeclaration("const", [
                            t.variableDeclarator(
                              t.identifier(splitType),
                              t.functionExpression(
                                splitNode.id || null,
                                // Anonymize the function expression
                                splitNode.params,
                                splitNode.body,
                                splitNode.generator,
                                splitNode.async
                              )
                            )
                          ])
                        );
                      } else if (t.isFunctionExpression(splitNode) || t.isArrowFunctionExpression(splitNode)) {
                        programPath.pushContainer(
                          "body",
                          t.variableDeclaration("const", [
                            t.variableDeclarator(
                              t.identifier(splitType),
                              splitNode
                            )
                          ])
                        );
                      } else if (t.isImportSpecifier(splitNode)) {
                        programPath.pushContainer(
                          "body",
                          t.variableDeclaration("const", [
                            t.variableDeclarator(
                              t.identifier(splitType),
                              splitNode.local
                            )
                          ])
                        );
                      } else {
                        console.log(splitNode);
                        throw new Error(
                          `Unexpected splitNode type: ${splitNode.type}`
                        );
                      }
                    }
                    programPath.node.body = programPath.node.body.filter(
                      (node) => {
                        return node !== splitNode;
                      }
                    );
                    programPath.pushContainer("body", [
                      t.exportNamedDeclaration(null, [
                        t.exportSpecifier(
                          t.identifier(splitType),
                          t.identifier(splitType)
                        )
                      ])
                    ]);
                  });
                  programPath.traverse({
                    ExportNamedDeclaration(path) {
                      if (path.node.declaration) {
                        if (t.isVariableDeclaration(path.node.declaration)) {
                          path.replaceWith(
                            t.importDeclaration(
                              path.node.declaration.declarations.map(
                                (decl) => t.importSpecifier(
                                  t.identifier(decl.id.name),
                                  t.identifier(decl.id.name)
                                )
                              ),
                              t.stringLiteral(
                                opts.filename.split(
                                  `?${splitPrefix}`
                                )[0]
                              )
                            )
                          );
                        }
                      }
                    }
                  });
                  eliminateUnreferencedIdentifiers(programPath);
                }
              }
            }
          },
          {
            root: process.cwd(),
            minify: process.env.NODE_ENV === "production"
          }
        ]
      ].filter(Boolean)
    })
  });
}
export {
  compileFile,
  makeCompile,
  splitFile
};
//# sourceMappingURL=compilers.js.map
