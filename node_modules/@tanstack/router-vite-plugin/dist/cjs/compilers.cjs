"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("@babel/types");
const template = require("@babel/template");
const babel = require("@babel/core");
const constants = require("./constants.cjs");
const eliminateUnreferencedIdentifiers = require("./eliminateUnreferencedIdentifiers.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const template__namespace = /* @__PURE__ */ _interopNamespaceDefault(template);
const babel__namespace = /* @__PURE__ */ _interopNamespaceDefault(babel);
function makeCompile(makeOpts) {
  return async (opts) => {
    const res = await babel__namespace.transform(opts.code, {
      plugins: [
        ["@babel/plugin-syntax-jsx", {}],
        [
          "@babel/plugin-syntax-typescript",
          {
            isTSX: true
          }
        ],
        ...opts.getBabelConfig().plugins
      ],
      root: makeOpts.root,
      filename: opts.filename,
      sourceMaps: true
    });
    if (res == null ? void 0 : res.code) {
      return {
        code: res.code,
        map: res.map
      };
    }
    return {
      code: opts.code,
      map: null
    };
  };
}
async function compileFile(opts) {
  return await opts.compile({
    code: opts.code,
    filename: opts.filename,
    getBabelConfig: () => ({
      plugins: [
        [
          {
            visitor: {
              Program: {
                enter(programPath, state) {
                  const splitUrl = `${constants.splitPrefix}:${opts.filename}?${constants.splitPrefix}`;
                  programPath.traverse(
                    {
                      CallExpression: (path) => {
                        if (path.node.callee.type === "Identifier") {
                          if (path.node.callee.name === "createRoute" || path.node.callee.name === "createFileRoute") {
                            if (path.parentPath.node.type === "CallExpression") {
                              const options = resolveIdentifier(
                                path,
                                path.parentPath.node.arguments[0]
                              );
                              let found = false;
                              if (t__namespace.isObjectExpression(options)) {
                                options.properties.forEach((prop) => {
                                  if (t__namespace.isObjectProperty(prop)) {
                                    if (t__namespace.isIdentifier(prop.key)) {
                                      if (prop.key.name === "component") {
                                        const value = prop.value;
                                        if (t__namespace.isIdentifier(value)) {
                                          removeIdentifierLiteral(path, value);
                                        }
                                        programPath.unshiftContainer("body", [
                                          template__namespace.smart(
                                            `import { lazyRouteComponent } from '@tanstack/react-router'`
                                          )(),
                                          template__namespace.smart(
                                            `const $$splitComponentImporter = () => import('${splitUrl}')`
                                          )()
                                        ]);
                                        prop.value = template__namespace.expression(
                                          `lazyRouteComponent($$splitComponentImporter, 'component')`
                                        )();
                                        programPath.pushContainer("body", [
                                          template__namespace.smart(
                                            `function DummyComponent() { return null }`
                                          )()
                                        ]);
                                        found = true;
                                      } else if (prop.key.name === "loader") {
                                        const value = prop.value;
                                        if (t__namespace.isIdentifier(value)) {
                                          removeIdentifierLiteral(path, value);
                                        }
                                        programPath.unshiftContainer("body", [
                                          template__namespace.smart(
                                            `import { lazyFn } from '@tanstack/react-router'`
                                          )(),
                                          template__namespace.smart(
                                            `const $$splitLoaderImporter = () => import('${splitUrl}')`
                                          )()
                                        ]);
                                        prop.value = template__namespace.expression(
                                          `lazyFn($$splitLoaderImporter, 'loader')`
                                        )();
                                        found = true;
                                      }
                                    }
                                  }
                                });
                              }
                              if (found) {
                                programPath.pushContainer("body", [
                                  template__namespace.smart(
                                    `function TSR_Dummy_Component() {}`
                                  )()
                                ]);
                              }
                            }
                          }
                        }
                      }
                    },
                    state
                  );
                  eliminateUnreferencedIdentifiers.eliminateUnreferencedIdentifiers(programPath);
                }
              }
            }
          },
          {
            root: process.cwd(),
            minify: process.env.NODE_ENV === "production"
          }
        ]
      ].filter(Boolean)
    })
  });
}
function resolveIdentifier(path, node) {
  if (t__namespace.isIdentifier(node)) {
    const binding = path.scope.getBinding(node.name);
    if (binding) {
      const declarator = binding.path.node;
      if (t__namespace.isObjectExpression(declarator.init)) {
        return declarator.init;
      } else if (t__namespace.isFunctionDeclaration(declarator.init)) {
        return declarator.init;
      }
    }
    return void 0;
  }
  return node;
}
function removeIdentifierLiteral(path, node) {
  if (t__namespace.isIdentifier(node)) {
    const binding = path.scope.getBinding(node.name);
    if (binding) {
      binding.path.remove();
    }
  }
}
const splitNodeTypes = ["component", "loader"];
async function splitFile(opts) {
  return await opts.compile({
    code: opts.code,
    filename: opts.filename,
    getBabelConfig: () => ({
      plugins: [
        [
          {
            visitor: {
              Program: {
                enter(programPath, state) {
                  const splitNodesByType = {
                    component: void 0,
                    loader: void 0
                  };
                  programPath.traverse(
                    {
                      CallExpression: (path) => {
                        if (path.node.callee.type === "Identifier") {
                          if (path.node.callee.name === "createFileRoute") {
                            if (path.parentPath.node.type === "CallExpression") {
                              const options = resolveIdentifier(
                                path,
                                path.parentPath.node.arguments[0]
                              );
                              if (t__namespace.isObjectExpression(options)) {
                                options.properties.forEach((prop) => {
                                  if (t__namespace.isObjectProperty(prop)) {
                                    splitNodeTypes.forEach((type) => {
                                      if (t__namespace.isIdentifier(prop.key)) {
                                        if (prop.key.name === type) {
                                          splitNodesByType[type] = prop.value;
                                        }
                                      }
                                    });
                                  }
                                });
                                options.properties = [];
                              }
                            }
                          }
                        }
                      }
                    },
                    state
                  );
                  splitNodeTypes.forEach((splitType) => {
                    let splitNode = splitNodesByType[splitType];
                    if (!splitNode) {
                      return;
                    }
                    while (t__namespace.isIdentifier(splitNode)) {
                      const binding = programPath.scope.getBinding(
                        splitNode.name
                      );
                      splitNode = binding == null ? void 0 : binding.path.node;
                    }
                    if (splitNode) {
                      if (t__namespace.isFunctionDeclaration(splitNode)) {
                        programPath.pushContainer(
                          "body",
                          t__namespace.variableDeclaration("const", [
                            t__namespace.variableDeclarator(
                              t__namespace.identifier(splitType),
                              t__namespace.functionExpression(
                                splitNode.id || null,
                                // Anonymize the function expression
                                splitNode.params,
                                splitNode.body,
                                splitNode.generator,
                                splitNode.async
                              )
                            )
                          ])
                        );
                      } else if (t__namespace.isFunctionExpression(splitNode) || t__namespace.isArrowFunctionExpression(splitNode)) {
                        programPath.pushContainer(
                          "body",
                          t__namespace.variableDeclaration("const", [
                            t__namespace.variableDeclarator(
                              t__namespace.identifier(splitType),
                              splitNode
                            )
                          ])
                        );
                      } else if (t__namespace.isImportSpecifier(splitNode)) {
                        programPath.pushContainer(
                          "body",
                          t__namespace.variableDeclaration("const", [
                            t__namespace.variableDeclarator(
                              t__namespace.identifier(splitType),
                              splitNode.local
                            )
                          ])
                        );
                      } else {
                        console.log(splitNode);
                        throw new Error(
                          `Unexpected splitNode type: ${splitNode.type}`
                        );
                      }
                    }
                    programPath.node.body = programPath.node.body.filter(
                      (node) => {
                        return node !== splitNode;
                      }
                    );
                    programPath.pushContainer("body", [
                      t__namespace.exportNamedDeclaration(null, [
                        t__namespace.exportSpecifier(
                          t__namespace.identifier(splitType),
                          t__namespace.identifier(splitType)
                        )
                      ])
                    ]);
                  });
                  programPath.traverse({
                    ExportNamedDeclaration(path) {
                      if (path.node.declaration) {
                        if (t__namespace.isVariableDeclaration(path.node.declaration)) {
                          path.replaceWith(
                            t__namespace.importDeclaration(
                              path.node.declaration.declarations.map(
                                (decl) => t__namespace.importSpecifier(
                                  t__namespace.identifier(decl.id.name),
                                  t__namespace.identifier(decl.id.name)
                                )
                              ),
                              t__namespace.stringLiteral(
                                opts.filename.split(
                                  `?${constants.splitPrefix}`
                                )[0]
                              )
                            )
                          );
                        }
                      }
                    }
                  });
                  eliminateUnreferencedIdentifiers.eliminateUnreferencedIdentifiers(programPath);
                }
              }
            }
          },
          {
            root: process.cwd(),
            minify: process.env.NODE_ENV === "production"
          }
        ]
      ].filter(Boolean)
    })
  });
}
exports.compileFile = compileFile;
exports.makeCompile = makeCompile;
exports.splitFile = splitFile;
//# sourceMappingURL=compilers.cjs.map
